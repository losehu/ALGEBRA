<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libg100: C:/libg100/include/memzones.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a></div>
<h1>C:/libg100/include/memzones.h</h1><pre class="fragment"><div>00001 <span class="comment">/*####################################################################################</span>
00002 <span class="comment"> #              This Code is part of the libg100 library : http://libg100.sf.net             #</span>
00003 <span class="comment"> #                                                                                                                                                                       #</span>
00004 <span class="comment"> #              THIS LIBRARY IS DISTRIBUTED "AS IS".                                                             #</span>
00005 <span class="comment"> #              NO WARRANTY OF ANY KIND IS EXPRESSED OR IMPLIED.                                                         #</span>
00006 <span class="comment"> #              YOU USE AT YOUR OWN RISK.                                                                                        #</span>
00007 <span class="comment"> #              THE AUTHOR WILL NOT BE LIABLE FOR DATA LOSS, DAMAGES,                                            #</span>
00008 <span class="comment"> #              LOSS OF PROFITS OR ANY OTHER KIND OF LOSS                                                        #</span>
00009 <span class="comment"> #              WHILE USING OR MISUSING THIS LIBRARY.                                                                    #</span>
00010 <span class="comment"> #                                                                                   #</span>
00011 <span class="comment"> #              This library is Distributed in LGPL License, read lgpl.txt or go to :            #</span>
00012 <span class="comment"> #                 http://opensource.org/licenses/lgpl-license.php                                                       #                                                                          #/</span>
00013 <span class="comment"> ####################################################################################*/</span>
00014 <span class="comment">/*********************************************</span>
00015 <span class="comment">**  memory_zone_libraries release 1.06      **</span>
00016 <span class="comment">**                                          **</span>
00017 <span class="comment">**  Copyright (c) John Wellesz 2001 - 2004  **</span>
00018 <span class="comment">**  All rights Reserved.                    **</span>
00019 <span class="comment">*********************************************/</span>
00020 
00021 
00022 
00023 <span class="preprocessor">#include &lt;stddef.h&gt;</span>
00024 
00025 <span class="comment">/*</span>
00026 <span class="comment"> * You must include this file in your source code and add mem_zones.c to your makefile or project file.</span>
00027 <span class="comment"> * #include "mem_zones.h"</span>
00028 <span class="comment"> */</span>
00029 
00030 
00031 <span class="comment">/*</span>
00032 <span class="comment"> * This structure is used by all the functions</span>
00033 <span class="comment"> * to have information about the memory zone.</span>
00034 <span class="comment"> * you have to define one and init it with the</span>
00035 <span class="comment"> * function search_mem_zone.</span>
00036 <span class="comment"> */</span>
00037 
00038 <span class="comment">//XXX</span>
00039 <span class="keywordtype">void</span> print_mzstruct (<span class="keyword">struct</span> memory_zone *mz);
00040 
00041 <span class="keyword">struct </span>memory_zone {
00042     <span class="keywordtype">int</span>          b_ztype;       <span class="comment">// indicates the zone id</span>
00043     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b_offset;      <span class="comment">// --|</span>
00044     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b_segment;     <span class="comment">// --| point on the size of the zone (3 bytes before the name).</span>
00045     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b_inner_offset;<span class="comment">//point on the offset where it cans start to write/read data.</span>
00046     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b_size;        <span class="comment">//total zone size.</span>
00047     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b_real_size;   <span class="comment">//the real size available for data (used to prevent overflow).</span>
00048     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b_name[10];   <span class="comment">//name of the zone.</span>
00049     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b_password[10];<span class="comment">//password (for basic files only).</span>
00050 };
00051 
00052 <span class="comment">// MACRO FOR COMPATIBILITY WITH OLDER VERSONS OF THIS LIB</span>
00053 <span class="preprocessor">#define search_basic_file(a,b)  search_mem_zone(1,a,b)</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#define BASICfile               memory_zone</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#define read_toBfile            read_mem_zone</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#define write_toBfile           write_mem_zone</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#define clear_basfile           clear_mem_zone</span>
00058 <span class="preprocessor"></span>
00059 <span class="comment">// Flags for the function create_mem_zone</span>
00060 <span class="preprocessor">#define CREATE_ZONE             0// Create a memory zone, if zone already exists it returns -1</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#define RESIZE_ZONE             2// create or change the size of an existing zone.</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#define DELETE_ZONE             3// can delete a memory zone.</span>
00063 <span class="preprocessor"></span>
00064 <span class="comment">// ######## internal use only #########</span>
00065 <span class="keyword">struct </span>zone_info {
00066     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  offset;
00067     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> seg;
00068 };
00069 
00070 <span class="keyword">struct </span>zone_info_num {
00071     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num;
00072 };
00073 <span class="comment">// ####################################</span>
00074 <span class="preprocessor">#if __cplusplus</span>
00075 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00076 <span class="preprocessor">#endif</span>
00077 <span class="preprocessor"></span>
00078 <span class="comment">/* -----------      create_mem_zone      -----------</span>
00079 <span class="comment"> * Creates a memory zone specified which type is given by "id" with the name "zonename", and a size of "size" bytes.</span>
00080 <span class="comment"> * (size &gt;= 14 and &gt;=24 for a basic file)</span>
00081 <span class="comment"> * it returns -1 in case of failure (already exist...) and -2 if not enough memory to create the file</span>
00082 <span class="comment"> * or not enough memory for the function itself.</span>
00083 <span class="comment"> * flag can be one of these values: CREATE_ZONE RESIZE_ZONE DELETE_ZONE</span>
00084 <span class="comment"> */</span>
00085 <span class="keywordtype">int</span> create_mem_zone(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> zone_id, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *zonename, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> flag);
00086 
00087 <span class="comment">/* -----------      search_mem_zone      -----------</span>
00088 <span class="comment"> * This function must be used one time before functions read_mem_zone, write_mem_zone or change_password</span>
00089 <span class="comment"> * to init the memory_zone structure</span>
00090 <span class="comment"> * then you will have to send the ====&gt; ADDRESS &lt;==== of this structure to the other functions.</span>
00091 <span class="comment"> * (you will have problems if you don't correctly understand the meaning od "address")</span>
00092 <span class="comment"> *</span>
00093 <span class="comment"> *  zonename is the name of the memory zone</span>
00094 <span class="comment"> *  zone_id is the id type of the memory zone you want to find</span>
00095 <span class="comment"> *  bf is the name of a memory_zone structure</span>
00096 <span class="comment"> *</span>
00097 <span class="comment"> *  this function returns the size of the memory zone if found and -1 if not.</span>
00098 <span class="comment"> */</span>
00099 <span class="keywordtype">long</span> search_mem_zone(<span class="keywordtype">int</span> zone_id, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *zone_name, <span class="keyword">struct</span> memory_zone *bf);
00100 
00101 <span class="comment">/* -----------      write_mem_zone      -----------</span>
00102 <span class="comment"> *</span>
00103 <span class="comment"> * This function works like the write function for real files,</span>
00104 <span class="comment"> * src can be everything, an int, a string, a structure...</span>
00105 <span class="comment"> * offset is the location in the memory zone where to write.</span>
00106 <span class="comment"> * length is the length in byte of src to write, if length &gt; b_size then only b_size -24 are written.</span>
00107 <span class="comment"> * So your calculator memory is protected it CAN only write within the memory zone pointed by bf.</span>
00108 <span class="comment"> */</span>
00109 
00110 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> write_mem_zone (<span class="keyword">struct</span> memory_zone *bf, <span class="keyword">const</span> <span class="keywordtype">void</span> *src, <span class="keywordtype">unsigned</span> offset, <span class="keywordtype">unsigned</span> length);
00111 
00112 
00113 <span class="comment">/* -----------      read_mem_zone      -----------</span>
00114 <span class="comment"> * works like the write one, dest can be everything an int, a string...</span>
00115 <span class="comment"> */</span>
00116 <span class="keywordtype">unsigned</span> read_mem_zone (<span class="keyword">struct</span> memory_zone *bf, <span class="keywordtype">void</span> *dest, <span class="keywordtype">unsigned</span> offset, <span class="keywordtype">unsigned</span> length);
00117 
00118 <span class="comment">/* -----------      clear_mem_zone      -----------</span>
00119 <span class="comment"> * This fill a memory zone with NULLs.</span>
00120 <span class="comment"> */</span>
00121 <span class="keywordtype">void</span>            clear_mem_zone
00122 (<span class="keyword">const</span> <span class="keyword">struct </span>memory_zone *bf);
00123 
00124 <span class="comment">/* -----------      change_password      -----------</span>
00125 <span class="comment"> * Well this change the password of a basic prog, password is the new one.</span>
00126 <span class="comment"> * */</span>
00127 <span class="keywordtype">void</span>            change_password
00128 (<span class="keyword">struct </span>memory_zone *bf, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *password);
00129 
00130 <span class="comment">/* -----------      afxleft               -----------</span>
00131 <span class="comment"> * This return the available memory for user's data in the afx memory.</span>
00132 <span class="comment"> * */</span>
00133 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> afxleft (<span class="keywordtype">void</span>);
00134 
00135 <span class="comment">/*############### The functions below are used by other function of this lib ###############*/</span>
00136 
00137 <span class="comment">/* -----------      tell_mem_zone_seg      -----------</span>
00138 <span class="comment"> * This function returns a pointer to the first zone which type is id (0&lt;=id&lt;0xF).</span>
00139 <span class="comment"> */</span>
00140 <span class="keywordtype">char</span> far *tell_mem_zone_seg( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <span class="keywordtype">id</span> );
00141 
00142 <span class="comment">/* --------      huge_movedata      --------</span>
00143 <span class="comment"> * Can move till 0xFFFFFFFF bytes of memory!</span>
00144 <span class="comment"> */</span>
00145 
00146 <span class="keywordtype">void</span>
00147 huge_movedata(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> src_seg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> src_off, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> des_seg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> des_off, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> num);
00148 
00149 <span class="keywordtype">void</span>
00150 my_movedata(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> src_seg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> src_off, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> des_seg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> des_off, size_t size_to_copy, <span class="keywordtype">int</span> direction);
00151 
00152 <span class="comment">/* --------      init_area      --------</span>
00153 <span class="comment"> *  clear an area of "size" (&lt;65536) bytes of memory since("direction"==0) or till(direction==1) b_segment:b_offset with the</span>
00154 <span class="comment"> *  two bytes contained in "value"</span>
00155 <span class="comment"> */</span>
00156 
00157 <span class="keywordtype">void</span> init_area(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b_segment, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b_offset, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> direction);
00158 
00159 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> give_absolute_add(<span class="keywordtype">void</span> far *pointer);
00160 
00161 <span class="keywordtype">void</span> far *give_far_pointer(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> abs_add);
00162 
00163 <span class="preprocessor">#if __cplusplus</span>
00164 <span class="preprocessor"></span>}
00165 <span class="preprocessor">#endif</span>
00166 <span class="preprocessor"></span>
00167 <span class="preprocessor">#define GIVE_SEG_ABSADD(a) ((u_int)((a)&gt;&gt; 4))</span>
00168 <span class="preprocessor"></span><span class="preprocessor">#define GIVE_OFF_ABSADD(a) ((u_int)((a) &amp; 0xF))</span>
00169 <span class="preprocessor"></span>
00170 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat Oct 30 00:12:26 2004 for libg100 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
